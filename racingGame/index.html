<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Tennis Game</title>
</head>
<body>
  <canvas id="gameCanvas" width="855" height="600"></canvas>
  <script>
//    debugger;
    var canvas;
    var canvasContext;

    // Ball's settings
    var ballX;
    var ballY;
    var ballSpeedX = 3;
    var ballSpeedY = 3;

    // Track's settings
    const TRACK_WIDTH = 80;
    const TRACK_HEIGHT = 20;
    const TRACK_GAP = 5;
    const TRACK_COLS = 10;
    const TRACK_ROWS = 14;
    var trackGrid = new Array(TRACK_COLS * TRACK_ROWS);
    var tracksLeft = 0;

    // Mouse settings
    var mouseX = 400;
    var mouseY;

    window.onload = function() {
      // save the canvas for dimensions, and its 2d context for drawing to it
      canvas = document.getElementById("gameCanvas");
      canvasContext = canvas.getContext('2d');

      trackReset();
      ballReset();

      canvas.addEventListener('mousemove', updateMousePos);


      var fps = 30;
      setInterval(updateAll, 1000 / fps);
    }

    function ballReset() {
      ballX = canvas.width / 2;
      ballY = canvas.height / 2;
    }

    function trackReset() {
      var trackCount = TRACK_ROWS * TRACK_COLS;
      var eachTrack = 0;
      var gutterAtTop = 3 * TRACK_COLS;
      for ( eachTrack; eachTrack < gutterAtTop; eachTrack++ ) {
        trackGrid[eachTrack] = false;        
      }
      for ( eachTrack; eachTrack < trackCount; eachTrack++ ) {
        // Show all tracks
        trackGrid[eachTrack] = true;
        tracksLeft++;

        // Show tracks randomly
        /*
        if (Math.random() < 0.5) {
          trackGrid[eachTrack] = true;
        } else {
          trackGrid[eachTrack] = false;
        }
        */
      }
    }

    function updateAll() {
      drawEverything();
      moveEverything();
    };

    function updateMousePos(event) {
       var rect = canvas.getBoundingClientRect();
       var root = document.documentElement;

       mouseX = event.clientX - rect.left - root.scrollLeft
       mouseY = event.clientY - rect.top - root.scrollTop;

       // cheat / to check for bugs 
       /*
       ballX = mouseX;
       ballY = mouseY;
       */
    }

    function colorRect(topLeftX, topLeftY, boxWidth, boxHeight, fillColor) {
      canvasContext.fillStyle = fillColor;
      canvasContext.beginPath();
      canvasContext.fillRect(topLeftX, topLeftY, boxWidth, boxHeight);
      canvasContext.fill();
    }

    function colorCircle(centerX, centerY, radius, fillColor) {
      canvasContext.fillStyle = fillColor;
      canvasContext.beginPath();
      canvasContext.arc(centerX, centerY, radius, 0, Math.PI * 2, true);
      canvasContext.fill();
    }

    function colorText(showText, textX, textY, fillColor) {
      canvasContext.fillStyle = fillColor;
      canvasContext.fillText(showText, textX, textY);
    }

    function drawTracks() {
      for (var numOfRow = 0; numOfRow < TRACK_ROWS; numOfRow++) {
        var y = (TRACK_HEIGHT + TRACK_GAP) * numOfRow + TRACK_GAP;
        for (var numOfCol = 0; numOfCol < TRACK_COLS; numOfCol++) {
          var x = (TRACK_WIDTH + TRACK_GAP) * numOfCol + TRACK_GAP;
          if ( trackGrid[numOfRow * TRACK_COLS + numOfCol] ) {
            colorRect(x, y, TRACK_WIDTH, TRACK_HEIGHT, "blue");
          }
        }
      }
    }

    function drawEverything() {
      colorRect(0, 0, canvas.width, canvas.height, '#000');

      colorCircle(ballX, ballY, 10, '#fff');

      drawTracks();
    }

    function ballMove() {
      ballX += ballSpeedX;
      ballY += ballSpeedY;     

      // reflects a ball from canvas ages
      if ( ballX < 0 && ballSpeedX < 0.0) ballSpeedX *= -1;
      if ( ballX > canvas.width && ballSpeedX > 0.0) ballSpeedX *= -1;
      if ( ballY < 0 && ballSpeedY < 0.0) ballSpeedY *= -1;
      if ( ballY > canvas.height ) {
        ballReset();
        trackReset();
      }
    }

    function ballTrackHandling() {
      // removes tracks when ball touches
      var trackColUnderBall = Math.floor(ballX / (TRACK_WIDTH + TRACK_GAP) + 1);
      var trackRowUnderBall = Math.floor(ballY / (TRACK_HEIGHT + TRACK_GAP) + 1);
      var trackIndexUnderBall = ((trackRowUnderBall - 1) * TRACK_COLS + trackColUnderBall) - 1;
      if ( trackIndexUnderBall < trackGrid.length && 
           trackGrid[trackIndexUnderBall] ) {
        if ( trackColUnderBall >= 1 && trackColUnderBall <= TRACK_COLS && 
             trackRowUnderBall >= 1 && trackColUnderBall <= TRACK_ROWS ) {
          trackGrid[trackIndexUnderBall] = false;  
          tracksLeft--;
          console.log(tracksLeft);

          //  where to reflect the ball
          var prevBallX = ballX - ballSpeedX;
          var prevBallY = ballY - ballSpeedY;
          var prevTrackColUnderBall = Math.floor(prevBallX / (TRACK_WIDTH + TRACK_GAP) + 1);
          var prevTrackRowUnderBall = Math.floor(prevBallY / (TRACK_HEIGHT + TRACK_GAP) + 1);
          
          if (prevTrackColUnderBall != trackColUnderBall) ballSpeedX *= -1;
          if (prevTrackRowUnderBall != trackRowUnderBall) ballSpeedY *= -1;
        } // end of fix track on opposite edge removing bug        
      } // end of checking if the ball above the existing track
    } // end of function

    function moveEverything() {
      ballMove();
      ballTrackHandling();
    }

  </script>
</body>
</html>